\section{Тема 15}

\subsection{Тегловни графи. Минимално покриващо дърво на тегловен граф. МПД свойство.}

\begin{definition}
	\textbf{Тегловен ориентиран мултиграф} е наредена четворка \mexpr{G = (V, E, f_G, w)},
	където \(V\) е непразно множество от върхове, \(E\) е множество от ребра,
	\mexpr{V \cap E = \emptyset, f_G: E \to V \times V} е свързваща функция и
	\mexpr{w: E \to \mathbb{R}} е тегловната функция.
\end{definition}

\begin{note}
	Стойността \(w(e)\) за \(e \in E\), наричаме цена или тегло на реброто \(e\).

	Цена на покриващо дърво \mexpr{T = (V, E'), E' \subseteq E} е сумата
	\mexpr{w(T) = \sum_{e \in E'} w(e)}
\end{note}

\begin{definition}
	Покриващото дърво \(T\) на \(G\), наричаме \textbf{минимално \linebreak (максимално)}, ако
	\mexpr{w(T) \le w(T')} (съответно \mexpr{w(T') \ge w(T)}) за всяко друго покриващо дърво \(T'\) на \(G\).
\end{definition}

\begin{theorem}[МПД-свойство]
	Нека \(G = (V, E)\) е свързан граф с тегловна функция \(w: E \to \mathbb{R}\), \(U \subseteq V, U \not =
	\emptyset\) и \(e = \{u, v\} \in E\) е такова, че \mexpr{u \in U, v \in V \setminus U} и измежду
	всички ребра \(e' = \{u', v'\}\) за \(u' \in U, v' \in V \setminus U\), реброто \textbf{e} е с
	най-ниска цена, т.е. \(w(e) \le w(e')\). Тогава \(G\) има минимално покриващо дърво, в което
	участва \(e\).
\end{theorem}

\begin{proof}
	Нека \(D(V, E_0)\) е минимално покриващо дърво. Да допуснем, че \(e\) не участва в \(E_0\). Тогава в
	\(D\) има път от \(u\) до \(v\): \(u = u_0, u_1, ..., u_k = v\). В този път участва поне едно ребро
	\mexpr{e' = \{u_i, u_{i + 1}\}} такова, че \(u_i \in U\) и \(u_{i + 1} \in V \setminus U\). Така в
	графа \mexpr{D' = (V, E_0 \cup \{e\})} има цикъл \mexpr{v, u = u_0, u_1, ..., u_k = v}. Тогава
	графът \mexpr{D''= (V, (E_0 \cup \{e\}) \setminus \{e'\})} е свързан и има покриващо дърво \((V, E_1)\),
	където \mexpr{e \in E_1 \subseteq (E_0 \setminus \{e\}) \setminus \{e'\}}. По условие \(w(e) \le w(e')\),
	следователно:
	\begin{equation*}
		\sum_{e \in E_1} w(e) \le \sum_{e \in (E_0 \cup \{e\}) \setminus \{e'\}} w(e) \le
		\sum_{e \in E_0} w(e)
	\end{equation*}
\end{proof}

\subsection{Алгоритми на Прим и Крускал. Коректност на тези алгоритми.}

\begin{alg}[на Прим]
	Алгоритъмът на Прим строи МПД на \(G\).

	Вход: свързан граф \(G = (V, E)\) и ф-я \(w: E \to \mathbb{R}\), задаваща тегла на
	ребрата му

	Изход: МПД \(D(V, E')\) с корен зададен връх \(r \in V\) на \(G\)
	\begin{enumerate}
		\item Построяваме дървото \(D_0(V_0, E_0), V_0 = \{r\}, E_0 = \emptyset, k = 0\)
		\item Нека сме построили \(D_k(V_k, E_k)\). Търсим реброто \(e = (v_i, v_j), v_i \in V_k,
		      v_j \in V \setminus V_k\) с минимално тегло и построяваме \(D_{k + 1} (V_{k + 1}, E_{k + 1})\),
		      където \(V_{k + 1} = V_k \cup \{v_j\}, E_{k + 1} = E_k \cup \{e\}\) и \(k = k + 1\)
		\item Ако \(V_k = V\), то полученото дърво \(D(V, E'), E' = E_k\) е оптималното и терминираме
		      алгоритъма, иначе отиваме на 2).
	\end{enumerate}
\end{alg}

\begin{proof}[Доказателство за коректност]
	За първата стъпка на алгоритъма избираме \(U = \{r\}\). Тогава трябва да изберем най-лекото ребро,
	излизащо от \(r\) и алгоритъмът прави точно това. Щом избраното ребро на тази стъпка може да участва
	в МПД, значи то образува сигурно за \(G\) м-во, а от друга страна е дърво - началото на
	бъдещото МПД. От тук нататък, нека на всяка стъпка избираме за м-во \(U\) върховете \(V_i\) на
	построената до момента част от МПД, а за \(A\) - участващите в него ребра \(E_i\). Тогава
	най-лекото ребро от \(U\) към \(V \setminus U\) е сигурно за \(A = E_i\) и може да продължим с него
	построяването на МПД. Това гарантира, че построеното от алгоритъма дърво е минимално.
\end{proof}

\begin{alg}[на Крускал]
	Алгоритъмът на Крускал строи МПД на \(G\).

	Вход: свързан граф \(G = (V, E)\) и ф-я \(w: E \to \mathbb{R}\), задаваща тегла на ребрата му

	Изход: МПД \(D = (V, E')\) на \(G\)
	\begin{enumerate}
		\item Сортираме ребрата на \(G\) в нарастващ ред по цената им и нека този ред е \(e_1, ..., e_m\)
		\item От всеки връх \(v\) на графа образуваме тривиално дърво \(D_V(\{v\}, \emptyset)\).
		\item За всяко ребро \(e_i = (v_{i_1}, v_{i_2}), i \in I_m\) правим следното:
		      ако \(v_{i_1}, v_{i_2}\) са в различни дървета, \(D'(V', E')\) и \(D''(V'', E'')\)
		      съответно, съединяваме двете в дървото \mexpr{D(V' \cup V'', E' \cup E'' \cup \{(v_{i_1}, v_{i_2})\})}.
	\end{enumerate}
\end{alg}

\begin{proof}[Доказателство за коректност]
	Да допуснем, че алгоритъмът не е коректен, т.е. не съществува дърво с по-малка тегловност от този в
	алгоритъма.

	Нека алгоритъмът бърка за реброто \(e_t\), което е било добавено и свързва две дървета \(T'\) и \(T''\).
	\begin{enumerate}
		\item Алгоритъмът е взел \(e_t\), защото между двете дървета няма друго ребро с по-малка тежест от
		      полученото \(\implies\) противоречие с допускането
		\item Ако \mexpr{w(e_i) \not = w(e_j)} за всяко \(i \not = j \implies\) съществува единствено
		      МПД, но ако има ребра с еднаква тежест, то ще има м-во от дървета.
	\end{enumerate}
\end{proof}
